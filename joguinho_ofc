import pygame
from random import randint
from math import sqrt
width = 800
height = 600
hero_pos_x = 1
hero_pos_y = 1
hero_vel = 0.3
enemies = []
spawn_timer = 0
enemy_spawn_interval = 1000
projectiles = []
shoot_time = 0
shoot_rate = 2000
time = 0
death = False
invencible = False
invencible_actualTime = 0
invencible_lengt = 1000
life = 6
enemyDeathCount = 0
nivel = 1
xp = 0

def load_mapa(filename):    #Lê o conteúdo do arquivo para a matriz
    pass

def escalonamentoXp (nivel):
    if nivel == 1:
        return 5
    if nivel == 20:
        return 600 + escalonamentoXp(nivel-1)
    if nivel == 40:
        return 2600 + escalonamentoXp(nivel-1)
    return 10 + escalonamentoXp (nivel-1)

xp_necessario = escalonamentoXp(nivel+1)

def ganhar_xp(valor):
    global xp, nivel, xp_necessario

    xp += valor

    # Verifica se subiu de nível
    while xp >= xp_necessario:
        nivel += 1
        print(f"Subiu para o nível {nivel}!")
        xp_necessario = escalonamentoXp(nivel + 1)
    
def spawn_enemy ():
    global hero_pos_x, hero_pos_y
    min_distancia = 300  # distância mínima do jogador
    max_tentativas = 20  # evita loop infinito

    for _ in range(max_tentativas):
        x = randint(0, width - 20)
        y = randint(0, height - 20)

        dx = x - hero_pos_x
        dy = y - hero_pos_y
        distancia = sqrt(dx**2 + dy**2)

        if distancia >= min_distancia:
            enemy = {
                "posX": x,
                "posY": y,
                "vel": 0.1
            }
            enemies.append(enemy)
            break

def shoot(dx, dy):
    global hero_pos_x, hero_pos_y, projectiles

    tiro = {
        "x": hero_pos_x + 16,
        "y": hero_pos_y + 16,
        "vel": 1,
        "alvo": None  # será preenchido com o inimigo mais próximo
    }

    # Define o alvo mais próximo:
    if enemies:
        inimigoMaisProx = min(enemies, key=lambda e: sqrt((e['posX'] - hero_pos_x) ** 2 + (e['posY'] - hero_pos_y) ** 2))
        tiro["alvo"] = inimigoMaisProx

    projectiles.append(tiro)

def load():
    global clock, collider_jogador, collider_mapa, coracao
    clock = pygame.time.Clock() 
    collider_mapa = [
        pygame.Rect(0,0,-10,600),
        pygame.Rect(0,0,800,-10),
        pygame.Rect(800,0,810,600),
        pygame.Rect(0, 600, 800, 610)
    ]
    coracao = pygame.image.load('coracao.png')

def update(dt):
    global hero_pos_x, hero_pos_y, hero_vel, collider_jogador, spawn_timer, enemy_spawn_interval, shoot_time, death, time, cronometro, enemyDeathCount, life, invencible_actualTime, invencible, qtdXP

    old_hero_pos_x, old_hero_pos_y = hero_pos_x, hero_pos_y
    keys = pygame.key.get_pressed()
    qtdTeclasApertadas = 0
    collider_jogador = pygame.Rect(hero_pos_x, hero_pos_y, 32, 32)

    if keys[pygame.K_RIGHT]:
        hero_pos_x += (hero_vel * dt)
        qtdTeclasApertadas += 1
        if hero_pos_x > 768:
            hero_pos_x = old_hero_pos_x    

    if keys[pygame.K_LEFT]:
        hero_pos_x += - (hero_vel * dt)
        qtdTeclasApertadas += 1
        if hero_pos_x < 0:
            hero_pos_x = old_hero_pos_x

    if keys[pygame.K_UP]:
        hero_pos_y += - (hero_vel * dt)
        qtdTeclasApertadas += 1
        if hero_pos_y < 0:
            hero_pos_y = old_hero_pos_y    

    if keys[pygame.K_DOWN]:
        hero_pos_y += (hero_vel * dt)
        qtdTeclasApertadas += 1
        if hero_pos_y > 568:
            hero_pos_y = old_hero_pos_y
    
    if qtdTeclasApertadas > 1:
        hero_vel = 0.3 / 2 ** (1/2)
    if qtdTeclasApertadas == 1:
        hero_vel = 0.3
    
    spawn_timer += dt
    if spawn_timer >= enemy_spawn_interval:
        spawn_enemy()
        spawn_timer = 0
    
    inimigoMaisProx = None
    distMenor = float('inf')
    for enemy in enemies:
        distanciaJxE_X = enemy['posX'] - hero_pos_x
        distanciaJxE_Y = enemy['posY'] - hero_pos_y
        distanciaGeral = sqrt(distanciaJxE_X**2 + distanciaJxE_Y**2)

        if distanciaGeral < distMenor:
            distMenor = distanciaGeral
            inimigoMaisProx = enemy

        if enemy['posX'] > hero_pos_x:
            enemy['posX'] -= (enemy['vel']*dt)
        elif enemy['posX'] < hero_pos_x:
            enemy['posX'] += (enemy['vel']*dt)
        else:
            enemy['posX'] = enemy['posX']
        
        if enemy['posY'] > hero_pos_y:
            enemy['posY'] -= (enemy['vel']*dt)
        elif enemy['posY'] < hero_pos_y:
            enemy['posY'] += (enemy['vel']*dt)
        else:
            enemy['posY'] = enemy['posY']

        collider_enemy = pygame.Rect(enemy['posX'], enemy['posY'], 20,20)

        if collider_jogador.colliderect(collider_enemy) and not invencible:
            life -= 1
            invencible = True
            invencible_actualTime = 0
            if life == 0:
                death = True
    
    shoot_time += dt
    if shoot_time >= shoot_rate and inimigoMaisProx:
        dx = inimigoMaisProx["posX"] - hero_pos_x
        dy = inimigoMaisProx["posY"] - hero_pos_y
        shoot(dx, dy)
        shoot_time = 0
    
    time += dt/1000
    if time < 10:
        cronometro = f'00:0{int(time)}'
    elif time < 60:
        cronometro = f'00:{int(time/10)}{int(time%10)}'
    elif time < 600:
        cronometro = f'0{int(time//60)}:{int(time%60//10)}{int(time%60%10)}'
    elif time < 6000:
        cronometro = f'{int(time//60)}:{int(time%60//10)}{int(time%60%10)}'

    for tiro in projectiles[:]:
         alvo = tiro["alvo"]
         if alvo not in enemies:
            projectiles.remove(tiro)
            continue

         dx = alvo['posX'] - tiro['x']
         dy = alvo['posY'] - tiro['y']
         dist = sqrt(dx**2 + dy**2)

         if dist != 0:
             tiro['x'] += (tiro['vel'] * dx / dist) * dt
             tiro['y'] += (tiro['vel'] * dy / dist) * dt

         # Checa colisão
         tiro_rect = pygame.Rect(tiro["x"], tiro["y"], 5, 5)
         alvo_rect = pygame.Rect(alvo["posX"], alvo["posY"], 20, 20)
         if tiro_rect.colliderect(alvo_rect):
            enemyDeathCount += 1
            ganhar_xp(1)
            enemies.remove(alvo)
            projectiles.remove(tiro)
    
    if invencible:
        invencible_actualTime += dt
        if invencible_actualTime>= invencible_lengt:
            invencible = False
            invencible_actualTime = 0
            
def draw_screen(screen):
    screen.fill((0,0,0))
    if not death:
        pygame.draw.rect(screen,("#00ff00"), collider_jogador)
        fonteCronometro = pygame.font.SysFont(None, 25)
        cronometroTxt = fonteCronometro.render(cronometro, True, '#ffffff')
        screen.blit(cronometroTxt, (370,0))
        for enemy in enemies:
            collider_enemy = pygame.Rect(enemy['posX'], enemy['posY'], 20,20)
            pygame.draw.rect(screen,("#ff0000"), collider_enemy)
        for tiro in projectiles:
            pygame.draw.rect(screen, "#ffffff", pygame.Rect(tiro["x"], tiro["y"], 5, 5))
        fonteKillCount = pygame.font.SysFont(None,20)
        killCountTxt = fonteKillCount.render(f'Inimigos Mortos: {enemyDeathCount}', True, '#ffffff')
        screen.blit(killCountTxt, (670,0))
        fonteXP = pygame.font.SysFont(None, 20)
        xpTxt = fonteXP.render(f'Nível: {nivel} | XP: {xp}/{xp_necessario}', True, '#ffffff')
        screen.blit(xpTxt, (10, 580))
        x = 0
        for i in range (life):
            if i % 2 == 0:
                screen.blit(coracao, (x,0))
            else:
                screen.blit(pygame.transform.flip(coracao, True,False),(x,0))
                x += 5
            x += 13
            
            
    else:
        fontedeath = pygame.font.SysFont(None, 100)
        texto = fontedeath.render('VOCÊ MORREU!', True, "#D51B1B")
        screen.blit(texto, (120, 250))

#####################################################
# A PRINCIPIO NÃO PRECISA ALTERAR DAQUI PRA BAIXO   #
#####################################################
def main_loop(screen):  
    global clock
    running_right = True
    while running_right:
        for e in pygame.event.get(): 
            if e.type == pygame.QUIT: # fechamento do prog
                running_right = False
                break

        # Define FPS máximo
        clock.tick(60)
        # time transcorrido desde a última atualização 
        dt = clock.get_time()
        # Atualiza posição dos objetos
        update(dt)
        # Desenha objetos
        draw_screen(screen)
        # Pygame atualiza a visualização da tela
        pygame.display.update()

# Programa principal
pygame.init()
screen = pygame.display.set_mode((width, height))
load()
main_loop(screen)
pygame.quit()
import pygame
from random import randint, sample
from math import sqrt, pi, cos, sin
width = 800
height = 600
noMenu = True
hero_pos_x = 376
hero_pos_y = 276
hero_vel = 0.2
hero_idle = []
hero_walking = []
alien_walking = []
hero_walking_frame = 0
hero_walking_time = 0
moving = False
hero_idle_frame = 0
hero_idle_time = 0
enemiesMelee = []
spawnMelee_timer = 0
enemyMelee_spawn_interval = 1000
enemiesRanged = []
spawnRanged_timer = 0
enemyRanged_spawn_interval = 5000
enemiesGlobal = []
projectiles = []
enemyProjectiles = []
orbitals       = []   # projéteis que orbitam o herói
orbital_level  = 0    # quantas balas na órbita
velOrb = 0.001
collisions = []
shoot_time = 0
shoot_rate = 2000
shoot_damage = 10
time = 0
death = False
paused = False
justUpgraded = False
InvencibleP = False
InvencibleP_actualTime = 0
InvencibleP_lengt = 1000
InvencibleE_lengt = 250
life = 1
enemyDeathCount = 0
nivel = 1
xp = 0
bounce = 1
opcoes_sorteadas = []
circleDamage = 0
circleRadius = 0
escolhendo_habilidade = False
weapons = [
    ['Recarga Bola de Neve', 0], #atira mais rápido
    ['Bola de Neve Orbital',0], #gira em torno do pinguim
    ['Vida', 0], #aumenta a vida
    ['Bola de Neve Elástica', 0], #bola de neve que quica
    ['Bola de Neve Poderosa', 0], #bola de neve dá mais dano
    ['Lágrimas de Pinguim', 0], #área que dá dano em volta
    ['Velocidade Movimento', 0] #aumenta a velocidade do pinguim
]



def load_mapa(filename):    #Lê o conteúdo do arquivo para a matriz
    pass

def rebuild_orbitals():
    """Reconstrói o anel de balas conforme orbital_level."""
    global orbitals, velOrb
    orbitals = []
    if orbital_level == 0:
        return
    passo = 2*pi / orbital_level
    for i in range(orbital_level):
        orbitals.append({
            "angle" : i*passo,
            "speed" : velOrb,        # rad/ms
            "radius": 100,  # raio aumenta um pouco a cada nível
            "size"  : 6,
            "damage": shoot_damage//2   # usa mesmo dano base
        })

def colide_circulo_retangulo(circle_x, circle_y, radius, rect):
    # Encontra o ponto mais próximo do centro do círculo dentro do retângulo (inimigo)
    closest_x = max(rect.left, min(circle_x, rect.right))
    closest_y = max(rect.top, min(circle_y, rect.bottom))
    
    # Calcula a distância do centro do círculo até esse ponto
    dx = circle_x - closest_x
    dy = circle_y - closest_y

    # Se a distância for menor ou igual ao raio, há colisão
    return (dx * dx + dy * dy) <= (radius * radius)

def selecionaArma (arma):
    global shoot_rate, life, bounce, shoot_damage, orbital_level, velOrb, circleRadius, circleDamage, hero_vel
    if arma[0] == 'Recarga Bola de Neve':
        shoot_rate = max(100, shoot_rate - 100)
    elif arma[0] == 'Vida':
        life += 2
    elif arma[0] == 'Bola de Neve Elástica':
        bounce += 1
    elif arma[0] == 'Bola de Neve Poderosa':
        shoot_damage += 2
    elif arma[0] == 'Bola de Neve Orbital':
        orbital_level += 1
        velOrb += 0.0005
        rebuild_orbitals()
    elif arma[0] == 'Lágrimas de Pinguim':
        if arma[1] == 0:
            circleRadius += 40
        elif arma[1] < 5:
            circleRadius += 10
        circleDamage += 1
    elif arma[0] == 'Velocidade Movimento':
        hero_vel += 0.005
    arma[1] += 1

def escalonamentoXp (nivel):
    global enemyMelee_spawn_interval
    if nivel == 2:
        return 5
    if nivel == 21:
        return 600 + escalonamentoXp(nivel-1)
    elif nivel == 42:
        return 2600 + escalonamentoXp(nivel-1)
    return 10 + escalonamentoXp (nivel-1)

xp_necessario = escalonamentoXp(nivel+1)

def ajustar_spawn_interval(nihero_vel_atual):
    global enemyMelee_spawn_interval
    if nihero_vel_atual < 21:          # 0–20
        enemyMelee_spawn_interval = 1000
    elif nihero_vel_atual < 41:        # 21–40
        enemyMelee_spawn_interval = 500
    elif nihero_vel_atual < 100:       # 41–99
        enemyMelee_spawn_interval = 250
    else:                         # 100+
        enemyMelee_spawn_interval = 20

def ganhar_xp(valor):
    global xp, nivel, xp_necessario, paused, enemyMelee_spawn_interval
    global opcoes_sorteadas, escolhendo_habilidade
    xp += valor
    if xp >= xp_necessario and nivel < 100:
        pygame.mixer.Sound.play(SomLvlUp)
        nivel += 1
        xp = 0
        paused = True
        ajustar_spawn_interval(nivel)
        escolhendo_habilidade = True
        # Sorteia 3 opções únicas
        opcoes_sorteadas = sample(weapons, k=3)
        xp_necessario = escalonamentoXp(nivel + 1)

def spawn_enemyMelee ():
    global hero_pos_x, hero_pos_y, vidaInimigo
    min_distancia = 200  # distância mínima do jogador
    max_tentativas = 20  # evita loop infinito
    vidaInimigo = 10 + (time*1//40)**2 
    for _ in range(max_tentativas):
        x = randint(0, width - 20)
        y = randint(0, height - 20)
        dx = x - hero_pos_x
        dy = y - hero_pos_y
        distancia = sqrt(dx**2 + dy**2)

        if distancia >= min_distancia:
            enemy = {
                "posX": x,
                "posY": y,
                "vel": 0.05,
                "life": vidaInimigo,
                "invencibility": False,
                "invencibility_actualTime": 0,
                "walking_frame": 0,
                "walking_time": 0
            }
            enemiesMelee.append(enemy)
            enemiesGlobal.append(enemy)
            break

def spawn_enemyRanged ():
    global hero_pos_x, hero_pos_y, vidaInimigo
    min_distancia = 200  # distância mínima do jogador
    max_tentativas = 20  # evita loop infinito
    vidaInimigo = 10 + (time*1//40)**2 
    for _ in range(max_tentativas):
        x = randint(0, width - 20)
        y = randint(0, height - 20)
        dx = x - hero_pos_x
        dy = y - hero_pos_y
        distancia = sqrt(dx**2 + dy**2)

        if distancia >= min_distancia:
            enemy = {
                "posX": x,
                "posY": y,
                "vel": 0.05,
                "life": vidaInimigo,
                "invencibility": False,
                "invencibility_actualTime": 0,
                "shoot_interval": 3000,
                "shoot_actualTime": 2999
            }
            enemiesRanged.append(enemy)
            enemiesGlobal.append(enemy)
            break

def shoot():
    global hero_pos_x, hero_pos_y, bounce

    tiro = {
        "x": hero_pos_x + 16,
        "y": hero_pos_y + 16,
        "vel": 1,
        "alvo": None,  # será preenchido com o inimigo mais próximo
        "bounc_rest": bounce,
        "damage": shoot_damage
    }

    # Define o alvo mais próximo:
    if enemiesGlobal:
        inimigoMaisProx = min(enemiesGlobal, key=lambda e: sqrt((e['posX'] - hero_pos_x) ** 2 + (e['posY'] - hero_pos_y) ** 2))
        tiro["alvo"] = inimigoMaisProx

    projectiles.append(tiro)

def enemyShoot (enemyPosX, enemyPosY):
    dx = (hero_pos_x + 16) - (enemyPosX + 10)
    dy = (hero_pos_y + 16) - (enemyPosY + 10)
    distancia = sqrt(dx**2 + dy**2)
    
    if distancia == 0:
        distancia = 1  # Evita divisão por zero

    velocidade = 0.1
    vx = (dx / distancia) * velocidade
    vy = (dy / distancia) * velocidade

    tiro = {
        "x": enemyPosX + 10,
        "y": enemyPosY + 10,
        "velX": vx,
        "velY": vy
    }
    enemyProjectiles.append(tiro)

def load():
    global clock, collider_jogador, collider_mapa, coracao, damage, orbitImage, lifeImage, menu, telaPause, somSnowballArrive, somSnowballLaunch, SomLvlUp, somDamage, cartaHabilidade, nave_inimiga, damageUpgradeImage, elasticImage, background, telaMorte, telaTransp
    clock = pygame.time.Clock() 
    collider_mapa = [
        pygame.Rect(0,0,-10,600),
        pygame.Rect(0,0,800,-10),
        pygame.Rect(800,0,810,600),
        pygame.Rect(0,600,800,610)
    ]
    coracao = pygame.image.load('coracao.png')
    
    for i in range(1, 3):
        hero_idle.append(pygame.transform.scale(pygame.image.load("pinguimNovoIdle" + str(i) + ".png"),(80,80)))
    for i in range (1,5):
        if i == 1 or i == 3:
            hero_walking.append(pygame.transform.scale(pygame.image.load("pinguimNovoIdle1.png"),(80,80)))
        else:
            hero_walking.append(pygame.transform.scale(pygame.image.load("pinguimNovoWalk" + str(i//2) + ".png"),(80,80)))
    for i in range (1,5):
        if i == 2 or i == 4:
            alien_walking.append(pygame.transform.scale(pygame.image.load("AlienWalk2.png"),(80,80)))
        else:
            alien_walking.append(pygame.transform.scale(pygame.image.load("AlienWalk" + str(i) + ".png"),(80,80)))
    damage = pygame.image.load('damage.png')
    orbitImage = pygame.transform.scale(pygame.image.load('orbitAbility2.png'), (120,120))
    lifeImage = pygame.transform.scale(pygame.image.load('lifeAbility2.png'),(120,120))
    elasticImage = pygame.transform.scale(pygame.image.load('icedalienz_bolaelastica.png'),(200,200))
    damageUpgradeImage =  pygame.transform.scale(pygame.image.load('icedalienz_nevepoderosa.png'),(300,300))
    menu = pygame.image.load('menu_icedalienz3.png')
    telaPause = pygame.transform.scale(pygame.image.load('pause_icedalienz.png'),(800,600))
    pygame.mixer_music.load("Flocos no Silêncio.mp3")
    somSnowballLaunch = pygame.mixer.Sound('BolaDeNeveLancamento.ogg')
    somSnowballArrive = pygame.mixer.Sound('Hit2.mp3')
    pygame.mixer.Sound.set_volume(somSnowballArrive,0.1)
    pygame.mixer.music.play(-1)
    pygame.mixer.music.set_volume(0.1)
    SomLvlUp = pygame.mixer.Sound('LevelUp.mp3')
    pygame.mixer.Sound.set_volume(SomLvlUp,0.1)
    somDamage = pygame.mixer.Sound('Damage.mp3')
    pygame.mixer.Sound.set_volume(somDamage,0.1)
    cartaHabilidade = pygame.image.load('icedalienzoverlay.png')
    nave_inimiga = pygame.transform.scale(pygame.image.load('nave_icedalienz.png'),(48,48))
    background = pygame.image.load('BackgroundIcedAlienz2.jpg')
    telaMorte = pygame.image.load('telaMorte.jpg')
    telaTransp = pygame.image.load('telaTransp.png')

def movimentacao_player (dt):
    global hero_pos_x, hero_pos_y, hero_vel, hero_idle_time, hero_idle_frame, hero_walking_time, hero_walking_frame, moving
    old_hero_pos_x, old_hero_pos_y = hero_pos_x, hero_pos_y, 
    keys = pygame.key.get_pressed()
    # 1. Verifica quantas teclas foram apertadas
    qtdTeclasApertadas = 0
    if keys[pygame.K_d]: qtdTeclasApertadas += 1
    if keys[pygame.K_a]: qtdTeclasApertadas += 1
    if keys[pygame.K_w]: qtdTeclasApertadas += 1
    if keys[pygame.K_s]: qtdTeclasApertadas += 1

    # 2. Aplica correção na velocidade ANTES do movimento
    hero_vel_atual = hero_vel
    if qtdTeclasApertadas > 1:
        hero_vel_atual = hero_vel_atual / (2 ** 0.5)  # Corrige para movimento diagonal

    # 3. Aplica o movimento com velocidade já corrigida
    moving = False
    if keys[pygame.K_d]:
        hero_pos_x += hero_vel_atual * dt
        moving = True
        if hero_pos_x > 768:
            hero_pos_x = old_hero_pos_x

    if keys[pygame.K_a]:
        hero_pos_x -= hero_vel_atual * dt
        moving = True
        if hero_pos_x < 0:
            hero_pos_x = old_hero_pos_x

    if keys[pygame.K_w]:
        hero_pos_y -= hero_vel_atual * dt
        moving = True
        if hero_pos_y < 0:
            hero_pos_y = old_hero_pos_y

    if keys[pygame.K_s]:
        hero_pos_y += hero_vel_atual * dt
        moving = True
        if hero_pos_y > 568:
            hero_pos_y = old_hero_pos_y
    
    # 4. Animações
    if qtdTeclasApertadas > 0:
        hero_walking_time += dt
        if hero_walking_time > 100:
            hero_walking_frame = (hero_walking_frame + 1) % 4
            hero_walking_time = 0
    else:
        hero_idle_time += dt
        if hero_idle_time > 200:
            hero_idle_frame = (hero_idle_frame + 1) % 2
            hero_idle_time = 0

def cronometrador (dt):
    global cronometro, time
    time += dt/1000
    if time < 10:
        cronometro = f'00:0{int(time)}'
    elif time < 60:
        cronometro = f'00:{int(time/10)}{int(time%10)}'
    elif time < 600:
        cronometro = f'0{int(time//60)}:{int(time%60//10)}{int(time%60%10)}'
    elif time < 6000:
        cronometro = f'{int(time//60)}:{int(time%60//10)}{int(time%60%10)}'

def funcionamentoRanged (dt):
    global spawnRanged_timer
    spawnRanged_timer += dt
    if spawnRanged_timer >= enemyRanged_spawn_interval:
        spawn_enemyRanged()
        spawnRanged_timer = 0

    distanciaMin = 200
    for enemy in enemiesRanged:
        distanciaJxE_X = enemy['posX'] - hero_pos_x
        distanciaJxE_Y = enemy['posY'] - hero_pos_y
        distancia = sqrt(distanciaJxE_X**2 + distanciaJxE_Y**2)
        enemy['shoot_actualTime'] += dt
        if distancia >= distanciaMin:
            if enemy['posX'] > hero_pos_x:
                enemy['posX'] -= (enemy['vel']*dt)
            elif enemy['posX'] < hero_pos_x:
                enemy['posX'] += (enemy['vel']*dt)
            else:
                enemy['posX'] = enemy['posX']
            
            if enemy['posY'] > hero_pos_y:
                enemy['posY'] -= (enemy['vel']*dt)
            elif enemy['posY'] < hero_pos_y:
                enemy['posY'] += (enemy['vel']*dt)
            else:
                enemy['posY'] = enemy['posY']
            
        else:
            if enemy["shoot_actualTime"] >= enemy["shoot_interval"]:
                enemyShoot(enemy['posX'],enemy['posY'])
                enemy["shoot_actualTime"] = 0

def funcionamentoInimigos (dt):
    global inimigoMaisProx, InvencibleP_actualTime, InvencibleP, collider_jogador, enemyDeathCount, life, death
    collider_jogador = pygame.Rect(hero_pos_x, hero_pos_y, 32, 32)

    inimigoMaisProx = None
    distMenor = float('inf')
    for enemy in enemiesGlobal:
        distanciaJxE_X = enemy['posX'] - hero_pos_x
        distanciaJxE_Y = enemy['posY'] - hero_pos_y
        distanciaGeral = sqrt(distanciaJxE_X**2 + distanciaJxE_Y**2)

        if distanciaGeral < distMenor:
            distMenor = distanciaGeral
            inimigoMaisProx = enemy

        collider_enemy = pygame.Rect(enemy['posX'], enemy['posY'], 24,30)

        if colide_circulo_retangulo(hero_pos_x+16,hero_pos_y+16,circleRadius,collider_enemy) and not enemy['invencibility']:
            enemy['life'] -= circleDamage
            enemy['invencibility'] = True
            enemy['invencibility_actualTime'] = 0
            if circleDamage != 0:
                collisions.append({
                        "dmg"   : circleDamage,
                        "x"     : enemy['posX'],
                        "y"     : enemy['posY'],
                        "timer" : 600          # milissegundos que o texto ficará visível
                    })
                
        if collider_jogador.colliderect(collider_enemy) and not InvencibleP:
            life -= 1
            InvencibleP = True
            InvencibleP_actualTime = 0
            pygame.mixer.Sound.play(somDamage)
            if life == 0:
                death = True
                pygame.mixer_music.stop()
                pygame.mixer_music.unload()
                pygame.mixer_music.load("Pinguim no Gelo.mp3")
                pygame.mixer_music.play(-1)
                pygame.mixer_music.set_volume(0.1)

        if enemy['invencibility']:
            enemy['invencibility_actualTime'] += dt
            if enemy['invencibility_actualTime'] >= InvencibleE_lengt:
                enemy['invencibility'] = False
                enemy['invencibility_actualTime'] = 0

        if enemy['life'] <= 0:
                enemiesGlobal.remove(enemy)
                if enemy in enemiesRanged:
                    enemiesRanged.remove(enemy)
                if not death:
                    enemyDeathCount += 1
                if vidaInimigo == 10 or vidaInimigo == 11:
                        ganhar_xp(1)
                else:
                    ganhar_xp((vidaInimigo-10)//2)

def funcionamentoMelee (dt):
    global spawnMelee_timer
    spawnMelee_timer += dt
    if spawnMelee_timer >= enemyMelee_spawn_interval:
        spawn_enemyMelee()
        spawnMelee_timer = 0
    
    for enemy in enemiesMelee:
        if enemy['posX'] > hero_pos_x:
            enemy['posX'] -= (enemy['vel']*dt)
        elif enemy['posX'] < hero_pos_x:
            enemy['posX'] += (enemy['vel']*dt)
        else:
            enemy['posX'] = enemy['posX']
        
        if enemy['posY'] > hero_pos_y:
            enemy['posY'] -= (enemy['vel']*dt)
        elif enemy['posY'] < hero_pos_y:
            enemy['posY'] += (enemy['vel']*dt)
        else:
            enemy['posY'] = enemy['posY']

        enemy["walking_time"] += dt
        if enemy["walking_time"] > 200:
            enemy["walking_frame"] = (enemy["walking_frame"] + 1) % 4
            enemy["walking_time"] = 0
    
def invencibilidadeJogador (dt):
    global justUpgraded, InvencibleP, InvencibleP_actualTime
    if InvencibleP:
        InvencibleP_actualTime += dt
        if InvencibleP_actualTime>= InvencibleP_lengt:
            InvencibleP = False
            justUpgraded = False
            InvencibleP_actualTime = 0

def danoNaTela (dt):
    for pop in collisions[:]:        # itera sobre cópia para poder remover
        pop["timer"] -= dt
        pop["y"] -= 0.03 * dt  
        if pop["timer"] <= 0:
            collisions.remove(pop)

def atira (dt):
    global shoot_time
    shoot_time += dt
    if shoot_time >= shoot_rate and inimigoMaisProx:
        shoot()
        #pygame.mixer.Sound.play(somSnowballLaunch)
        shoot_time = 0

def atualizaTiro (dt):
    for tiro in projectiles[:]:
         alvo = tiro["alvo"]
         if alvo not in enemiesGlobal:
            projectiles.remove(tiro)
            continue

         dx = alvo['posX'] - tiro['x']
         dy = alvo['posY'] - tiro['y']
         dist = sqrt(dx**2 + dy**2)

         if dist != 0:
             tiro['x'] += (tiro['vel'] * dx / dist) * dt
             tiro['y'] += (tiro['vel'] * dy / dist) * dt

         # Checa colisão
         tiro_rect = pygame.Rect(tiro["x"], tiro["y"], 5, 5)
         alvo_rect = pygame.Rect(alvo["posX"], alvo["posY"], 20, 20)
         if tiro_rect.colliderect(alvo_rect):
            if not alvo['invencibility']:
                pygame.mixer.Sound.play(somSnowballArrive)
                alvo['life'] -= tiro['damage']
                collisions.append({
                    "dmg"   : tiro['damage'],
                    "x"     : tiro['x'],
                    "y"     : tiro['y'],
                    "timer" : 600          # milissegundos que o texto ficará visível
                })
                alvo['invencibility'] = True
                alvo['invencibility_actualTime'] = 0
                tiro['bounc_rest'] -= 1

                if tiro['bounc_rest'] > 0 and (tiro['damage'] - 2) > 0:
                    tiro['damage'] -= 2
                    # candidatos = todos os inimigos EXCETO o que acabou de levar o hit
                    candidatos = [e for e in enemiesGlobal if e is not alvo]
                    if candidatos:                               # existe alguém além dele?
                        novo_alvo = min(
                            candidatos,
                            key=lambda e: sqrt((e['posX'] - tiro['x'])**2 + (e['posY'] - tiro['y'])**2)
                        )
                        tiro['alvo'] = novo_alvo
                        # opcional: empurra 1 px para fora do antigo alvo
                        dx2 = novo_alvo['posX'] - tiro['x']
                        dy2 = novo_alvo['posY'] - tiro['y']
                        dist2 = max(1, sqrt(dx2**2 + dy2**2))
                        tiro['x'] += dx2 / dist2
                        tiro['y'] += dy2 / dist2
                    else:
                        # não há outro alvo — descarta o projétil
                        projectiles.remove(tiro)
                else:
                    projectiles.remove(tiro)
            else:
                # inimigo ainda está invencível, não faz nada nesse frame
                pass

def atualizaTiroInimigo (dt):
    global hero_pos_x, hero_pos_y, life, InvencibleP, InvencibleP_actualTime, death
    for tiro in enemyProjectiles[:]:
        tiro['x'] += tiro['velX'] * dt
        tiro['y'] += tiro['velY'] * dt
        
        tiro_rect = pygame.Rect(tiro["x"], tiro["y"], 5, 5)
        if tiro_rect.colliderect(collider_jogador):
            if not InvencibleP:
                life -= 1
                InvencibleP = True
                InvencibleP_actualTime = 0
                enemyProjectiles.remove(tiro)
                pygame.mixer.Sound.play(somDamage)
                if life <= 0:
                    death = True
                    pygame.mixer_music.stop()
                    pygame.mixer_music.unload()
                    pygame.mixer_music.load("Pinguim no Gelo.mp3")
                    pygame.mixer_music.play(-1)
                    pygame.mixer_music.set_volume(0.1)
            else:
                enemyProjectiles.remove(tiro)

        if tiro['x'] < -10 or tiro['x'] > width + 10 or tiro['y'] < -10 or tiro['y'] > height + 10:
            enemyProjectiles.remove(tiro)

def atualizaOrbital(dt):
    for orb in orbitals:
        # avança ângulo
        orb["angle"] += orb["speed"] * dt
        # mantém ângulo na faixa 0..2π para evitar overflow
        if orb["angle"] > 6.283:
            orb["angle"] -= 6.283

        # posição relativa ao jogador
        cx = hero_pos_x + 16 + orb["radius"] * cos(orb["angle"])
        cy = hero_pos_y + 16 + orb["radius"] * sin(orb["angle"])

        orb_rect = pygame.Rect(cx - orb["size"]//2, cy - orb["size"]//2,
                            orb["size"], orb["size"])

        # colisão com inimigos (sem destruir a bala)
        for enemy in enemiesGlobal[:]:
            enemy_rect = pygame.Rect(enemy['posX'], enemy['posY'], 20, 20)
            if orb_rect.colliderect(enemy_rect) and not enemy['invencibility']:
                pygame.mixer.Sound.play(somSnowballArrive)
                enemy['life'] -= orb["damage"]
                collisions.append({
                    "dmg"   : shoot_damage//2,
                    "x"     : enemy['posX'],
                    "y"     : enemy['posY'],
                    "timer" : 600          # milissegundos que o texto ficará visível
                })
                enemy['invencibility'] = True
                enemy['invencibility_actualTime'] = 0
            
def draw_screen(screen):
    screen.fill(("#D5E8F2"))
    screen.blit(background,(-192,-36))
    if not death:
        pygame.draw.circle(screen,("#70aaff"),(hero_pos_x+16,hero_pos_y+16),circleRadius)
        if not moving:
            screen.blit(hero_idle[hero_idle_frame], (hero_pos_x-26, hero_pos_y-23))
        else:
            screen.blit(hero_walking[hero_walking_frame],(hero_pos_x-26, hero_pos_y-23))
        for enemy in enemiesGlobal:
            collider_enemy = pygame.Rect(enemy['posX'], enemy['posY'], 24,24)
            if enemy in enemiesRanged:
                screen.blit(nave_inimiga, (enemy['posX']-11, enemy['posY']-17))
            else:
                screen.blit(alien_walking[enemy["walking_frame"]], (enemy['posX']-29, enemy['posY']-28))
        for tiro in projectiles:
            pygame.draw.circle(screen, "#ffffff", (tiro["x"], tiro["y"]), 5)
        for tiro in enemyProjectiles:
            pygame.draw.circle(screen,"#ff0000",(tiro["x"], tiro["y"]), 4)
        fonteDamage = pygame.font.SysFont(None, 20)
        for pop in collisions:
            txt = fonteDamage.render(str(pop["dmg"]), True, "#ffffff")
            screen.blit(txt, (pop["x"], pop["y"]))
        for orb in orbitals:
            cx = hero_pos_x + 16 + orb["radius"] * cos(orb["angle"])
            cy = hero_pos_y + 16 + orb["radius"] * sin(orb["angle"])
            pygame.draw.circle(screen, "#ffffff",
                                        (cx - orb["size"]//2,
                                        cy - orb["size"]//2),
                                        5)
        if InvencibleP and InvencibleP_actualTime < 500 and not justUpgraded:
            screen.blit(damage,(0,0))
        fonteCronometro = pygame.font.SysFont(None, 30)
        cronometroTxt = fonteCronometro.render(cronometro, True, '#ffffff')
        screen.blit(cronometroTxt, (370,0))
        fonteKillCount = pygame.font.SysFont(None,20)
        killCountTxt = fonteKillCount.render(f'Inimigos Mortos: {enemyDeathCount}', True, '#ffffff')
        screen.blit(killCountTxt, (660,0))
        pygame.draw.rect(screen,("#999999"),(0,575,800,600))
        pygame.draw.rect(screen,("#1070cc"),(0,575,(xp/xp_necessario*800),600))
        fonteXP = pygame.font.SysFont(None, 20)
        xpTxt = fonteXP.render(f'Nível: {nivel}', True, '#ffffff')
        screen.blit(xpTxt, (375, 580))
        x = 0
        y = 0
        p = 0
        for i in range (life):
            if i % 2 == 0:
                screen.blit(coracao, (x,y))
            else:
                screen.blit(pygame.transform.flip(coracao, True,False),(x,y))
                x += 5
            x += 13
            p += 1
            if p % 24 == 0:
                y += 30
                x = 0

        if escolhendo_habilidade:
            font = pygame.font.SysFont(None, 15)
            screen.blit(cartaHabilidade,(100,225))
            screen.blit(cartaHabilidade,(325,225))
            screen.blit(cartaHabilidade,(550,225))
            for i, arma in enumerate(opcoes_sorteadas):
                txt = f"{arma[0]}"#(nível atual: {arma[1]})"
                rendered = font.render(txt, True, "#CAF0F8")
                screen.blit(rendered, (118+225*i, 380))
                if arma[0] == 'Vida':
                    screen.blit(lifeImage,(115+225*i,238))
                elif arma[0] == 'Bola de Neve Orbital':
                    screen.blit(orbitImage,(115+225*i,238))
                elif arma[0] == 'Bola de Neve Poderosa':
                    screen.blit(damageUpgradeImage,(50+225*i,140))
                elif arma[0] == 'Bola de Neve Elástica':
                    screen.blit(elasticImage,(85+225*i,185))

    else:
        screen.blit(telaMorte,(-192,-36))
        screen.blit(telaTransp,(0,0))
        fontedeath = pygame.font.SysFont(None, 100)
        texto = fontedeath.render('VOCÊ MORREU!', True, "#54FEFD")
        screen.blit(texto, (120, 95))
        fonteenemiesMelee = pygame.font.SysFont(None, 25)
        textoenemiesMelee2 = fonteenemiesMelee.render(f'Inimigos eliminados: {enemyDeathCount}', True, "#ffffff")
        screen.blit(textoenemiesMelee2,(500,250))
        fonteCron = pygame.font.SysFont(None, 25)
        textoCron = fonteCron.render(f'Tempo sobrevivido: {cronometro}',True,"#ffffff")
        screen.blit(textoCron,(270,250))
        fonteNivel = pygame.font.SysFont(None,25)
        textoNivel = fonteNivel.render(f'Nível alcançado: {nivel}', True, "#ffffff")
        screen.blit(textoNivel,(90,250))
        fonteRejogar = pygame.font.SysFont(None,40)
        textoRejogar = fonteRejogar.render('Pressione Espaço para Rejogar', True, "#ffffff")
        screen.blit(textoRejogar,(180,540))
        fonteVoltarMenu = pygame.font.SysFont(None,30)
        textoVoltarMenu = fonteVoltarMenu.render('Pressione m para voltar ao menu', True, "#ffffff")
        screen.blit(textoVoltarMenu,(180,570))

def draw_pause_overlay(screen):
    screen.blit(telaPause,(0,0))

def draw_menu(screen):
    screen.blit(menu,(0,0))

#####################################################
# A PRINCIPIO NÃO PRECISA ALTERAR DAQUI PRA BAIXO   #
#####################################################
def main_loop(screen):  
    global clock, paused, escolhendo_habilidade, bounce, spawnMelee_timer, xp_necessario ,circleDamage,shoot_rate, circleRadius,InvencibleP, nivel, xp, enemyDeathCount ,velOrb, shoot_damage ,justUpgraded, orbital_level, noMenu, death, life, hero_pos_x, hero_pos_y, time, hero_vel
    running_right = True
    while running_right:
        # Define FPS máximo
        clock.tick(60)
        # time transcorrido desde a última atualização 
        dt = clock.get_time()

        if not noMenu:
            for e in pygame.event.get(): 
                if e.type == pygame.QUIT: # fechamento do prog
                    running_right = False
                    break
                elif e.type == pygame.KEYDOWN:
                    if e.key == pygame.K_ESCAPE:
                        paused = not paused
                    if escolhendo_habilidade:
                        paused = True
                        InvencibleP = True
                        justUpgraded = True
                        if e.key == pygame.K_1:
                            selecionaArma(opcoes_sorteadas[0])
                            escolhendo_habilidade = False
                            paused = False
                        elif e.key == pygame.K_2:
                            selecionaArma(opcoes_sorteadas[1])
                            escolhendo_habilidade = False
                            paused = False
                        elif e.key == pygame.K_3:
                            selecionaArma(opcoes_sorteadas[2])
                            escolhendo_habilidade = False
                            paused = False

                    if death == True:
                        spawnMelee_timer = 0
                        life = 6
                        hero_pos_x = 376
                        hero_pos_y = 276
                        hero_vel = 0.2
                        orbital_level = 0
                        rebuild_orbitals()
                        velOrb = 0.001
                        time = 0
                        shoot_damage = 10
                        xp = 0
                        xp_necessario = 5
                        circleDamage = 0
                        circleRadius = 0
                        shoot_rate = 2000
                        bounce = 1
                        InvencibleP = False
                        for arma in weapons:
                            arma[1] = 0
                        if e.key == pygame.K_SPACE:
                            pygame.mixer_music.stop()
                            pygame.mixer_music.unload()
                            pygame.mixer_music.load("Aventuras Congelantes do Pinguim Atirador.mp3")
                            pygame.mixer_music.play(-1)
                            pygame.mixer_music.set_volume(0.1)
                            death = False
                            nivel = 1
                            enemyDeathCount = 0
                        if e.key == pygame.K_m:
                            noMenu = True
                            pygame.mixer_music.stop()
                            pygame.mixer_music.unload()
                            pygame.mixer_music.load("Flocos no Silêncio.mp3")
                            pygame.mixer_music.play(-1)
                            pygame.mixer_music.set_volume(0.1)
                            death = False
                            nivel = 1
                            enemyDeathCount = 0

            if death == True:
                spawnMelee_timer = 0
                for enemy in enemiesGlobal:
                    enemiesGlobal.remove(enemy)
                for pop in collisions:
                    collisions.remove(pop)
                for enemy in enemiesRanged:
                    enemiesRanged.remove(enemy)
                for projectile in enemyProjectiles:
                    enemyProjectiles.remove(projectile)

            # Atualiza posição dos objetos
            if not paused and not death:
                movimentacao_player(dt)
                cronometrador(dt)
                invencibilidadeJogador(dt)
                funcionamentoMelee(dt)
                funcionamentoInimigos(dt)
                funcionamentoRanged(dt)
                danoNaTela (dt)
                atira (dt)
                atualizaTiro (dt)
                atualizaOrbital(dt)
                atualizaTiroInimigo(dt)
            # Desenha objetos
            draw_screen(screen)
            if paused and not death and not escolhendo_habilidade:
                draw_pause_overlay(screen)
            # Pygame atualiza a visualização da tela
            pygame.display.update()
        else:
            draw_menu(screen)
            pygame.display.update()  # Atualiza o menu na tela
            for e in pygame.event.get():
                posX_mouse, posY_mouse = pygame.mouse.get_pos()
                if e.type == pygame.MOUSEBUTTONDOWN and 290 < posX_mouse < 510 and 380 < posY_mouse < 450:
                    noMenu = False 
                    pygame.mixer_music.stop()
                    pygame.mixer_music.unload()
                    pygame.mixer_music.load("Aventuras Congelantes do Pinguim Atirador.mp3")
                    pygame.mixer_music.play(-1)
                    pygame.mixer_music.set_volume(0.1)
                if e.type == pygame.QUIT: # fechamento do prog
                    running_right = False
                    break

# Programa principal
pygame.init()
screen = pygame.display.set_mode((width, height))
load()
main_loop(screen)
pygame.quit()

import pygame
from random import randint, sample
from math import sqrt, pi, cos, sin
width = 800
height = 600
noMenu = True
hero_pos_x = 376
hero_pos_y = 276
hero_vel = 0.2
hero_idle = []
hero_walking = []
hero_walking_frame = 0
hero_walking_time = 0
moving = False
hero_idle_frame = 0
hero_idle_time = 0
enemies = []
spawn_timer = 0
enemy_spawn_interval = 1000
projectiles = []
orbitals       = []   # projéteis que orbitam o herói
orbital_level  = 0    # quantas balas na órbita
velOrb = 0.001
collisions = []
shoot_time = 0
shoot_rate = 2000
shoot_damage = 10
time = 0
death = False
paused = False
justUpgraded = False
InvencibleP = False
InvencibleP_actualTime = 0
InvencibleP_lengt = 1000
InvencibleE_lengt = 250
life = 6
enemyDeathCount = 0
nivel = 1
xp = 0
bounce = 1
opcoes_sorteadas = []
circleDamage = 0
circleRadius = 0
escolhendo_habilidade = False
weapons = [
    ['Recarga Bola de Neve', 0], #atira mais rápido
    ['Bola de Neve Orbital',0], #gira em torno do pinguim
    ['Vida', 0], #aumenta a vida
    ['Bola de Neve Elástica', 0], #bola de neve que quica
    ['Bola de Neve Poderosa', 0], #bola de neve dá mais dano
    ['Lágrimas de Pinguim', 0], #área que dá dano em volta
    ['Velocidade Movimento', 0] #aumenta a velocidade do pinguim
]


def load_mapa(filename):    #Lê o conteúdo do arquivo para a matriz
    pass

def rebuild_orbitals():
    """Reconstrói o anel de balas conforme orbital_level."""
    global orbitals, velOrb
    orbitals = []
    if orbital_level == 0:
        return
    passo = 2*pi / orbital_level
    for i in range(orbital_level):
        orbitals.append({
            "angle" : i*passo,
            "speed" : velOrb,        # rad/ms
            "radius": 100,  # raio aumenta um pouco a cada nível
            "size"  : 6,
            "damage": shoot_damage//2   # usa mesmo dano base
        })

def colide_circulo_retangulo(circle_x, circle_y, radius, rect):
    # Encontra o ponto mais próximo do centro do círculo dentro do retângulo (inimigo)
    closest_x = max(rect.left, min(circle_x, rect.right))
    closest_y = max(rect.top, min(circle_y, rect.bottom))
    
    # Calcula a distância do centro do círculo até esse ponto
    dx = circle_x - closest_x
    dy = circle_y - closest_y

    # Se a distância for menor ou igual ao raio, há colisão
    return (dx * dx + dy * dy) <= (radius * radius)


def selecionaArma (arma):
    global shoot_rate, life, bounce, shoot_damage, orbital_level, velOrb, circleRadius, circleDamage, hero_vel
    if arma[0] == 'Recarga Bola de Neve':
        shoot_rate = max(100, shoot_rate - 100)
    elif arma[0] == 'Vida':
        life += 2
    elif arma[0] == 'Bola de Neve Elástica':
        bounce += 1
    elif arma[0] == 'Bola de Neve Poderosa':
        shoot_damage += 2
    elif arma[0] == 'Bola de Neve Orbital':
        orbital_level += 1
        velOrb += 0.0005
        rebuild_orbitals()
    elif arma[0] == 'Lágrimas de Pinguim':
        if arma[1] == 0:
            circleRadius += 40
        elif arma[1] < 5:
            circleRadius += 10
        circleDamage += 1
    elif arma[0] == 'Velocidade Movimento':
        hero_vel += 0.005
    arma[1] += 1

def escalonamentoXp (nivel):
    global enemy_spawn_interval
    if nivel == 2:
        return 5
    if nivel == 21:
        return 600 + escalonamentoXp(nivel-1)
    elif nivel == 42:
        return 2600 + escalonamentoXp(nivel-1)
    return 10 + escalonamentoXp (nivel-1)

xp_necessario = escalonamentoXp(nivel+1)
def ajustar_spawn_interval(nihero_vel_atual):
    global enemy_spawn_interval
    if nihero_vel_atual < 21:          # 0–20
        enemy_spawn_interval = 1000
    elif nihero_vel_atual < 41:        # 21–40
        enemy_spawn_interval = 750
    elif nihero_vel_atual < 100:       # 41–99
        enemy_spawn_interval = 250
    else:                         # 100+
        enemy_spawn_interval = 20

def ganhar_xp(valor):
    global xp, nivel, xp_necessario, paused, enemy_spawn_interval
    global opcoes_sorteadas, escolhendo_habilidade
    xp += valor
    if xp >= xp_necessario and nivel < 100:
        nivel += 1
        xp = 0
        paused = True
        ajustar_spawn_interval(nivel)
        escolhendo_habilidade = True
        # Sorteia 3 opções únicas
        opcoes_sorteadas = sample(weapons, k=3)
        xp_necessario = escalonamentoXp(nivel + 1)

def spawn_enemy ():
    global hero_pos_x, hero_pos_y, vidaInimigo
    min_distancia = 200  # distância mínima do jogador
    max_tentativas = 20  # evita loop infinito
    vidaInimigo = 10 + (time*1//40)**2 
    for _ in range(max_tentativas):
        x = randint(0, width - 20)
        y = randint(0, height - 20)
        dx = x - hero_pos_x
        dy = y - hero_pos_y
        distancia = sqrt(dx**2 + dy**2)

        if distancia >= min_distancia:
            enemy = {
                "posX": x,
                "posY": y,
                "vel": 0.05,
                "life": vidaInimigo,
                "invencibility": False,
                "invencibility_actualTime": 0
            }
            enemies.append(enemy)
            break

def shoot(dx, dy):
    global hero_pos_x, hero_pos_y, projectiles, bounce

    tiro = {
        "x": hero_pos_x + 16,
        "y": hero_pos_y + 16,
        "vel": 1,
        "alvo": None,  # será preenchido com o inimigo mais próximo
        "bounc_rest": bounce,
        "damage": shoot_damage
    }

    # Define o alvo mais próximo:
    if enemies:
        inimigoMaisProx = min(enemies, key=lambda e: sqrt((e['posX'] - hero_pos_x) ** 2 + (e['posY'] - hero_pos_y) ** 2))
        tiro["alvo"] = inimigoMaisProx

    projectiles.append(tiro)

def load():
    global clock, collider_jogador, collider_mapa, coracao, damage, orbitImage, lifeImage, menu, telaPause
    clock = pygame.time.Clock() 
    collider_mapa = [
        pygame.Rect(0,0,-10,600),
        pygame.Rect(0,0,800,-10),
        pygame.Rect(800,0,810,600),
        pygame.Rect(0,600,800,610)
    ]
    coracao = pygame.image.load('coracao.png')
    
    for i in range(1, 3):
        hero_idle.append(pygame.transform.scale(pygame.image.load("pinguimIdle" + str(i) + ".png"),(48,48)))
    for i in range (1,5):
        if i == 1 or i == 3:
            hero_walking.append(pygame.transform.scale(pygame.image.load("pinguimIdle1.png"),(48,48)))
        else:
            hero_walking.append(pygame.transform.scale(pygame.image.load("pinguimWalk" + str(i//2) + ".png"),(48,48)))
    damage = pygame.image.load('damage.png')
    orbitImage = pygame.transform.scale(pygame.image.load('orbitAbility.png'), (32,32))
    lifeImage = pygame.transform.scale(pygame.image.load('lifeAbility.png'),(32,32))
    menu = pygame.image.load('menu_icedalienz3.png')
    telaPause = pygame.transform.scale(pygame.image.load('pause_icedalienz.png'),(800,600))
    musica = pygame.mixer_music.load("Aventuras Congelantes do Pinguim Atirador.mp3")
    pygame.mixer.music.play(-1)
    pygame.mixer.music.set_volume(0.1)

def movimentacao_player (dt):
    global hero_pos_x, hero_pos_y, hero_vel, hero_idle_time, hero_idle_frame, hero_walking_time, hero_walking_frame, moving
    old_hero_pos_x, old_hero_pos_y = hero_pos_x, hero_pos_y, 
    keys = pygame.key.get_pressed()
    # 1. Verifica quantas teclas foram apertadas
    qtdTeclasApertadas = 0
    if keys[pygame.K_d]: qtdTeclasApertadas += 1
    if keys[pygame.K_a]: qtdTeclasApertadas += 1
    if keys[pygame.K_w]: qtdTeclasApertadas += 1
    if keys[pygame.K_s]: qtdTeclasApertadas += 1

    # 2. Aplica correção na velocidade ANTES do movimento
    hero_vel_atual = hero_vel
    if qtdTeclasApertadas > 1:
        hero_vel_atual = hero_vel_atual / (2 ** 0.5)  # Corrige para movimento diagonal

    # 3. Aplica o movimento com velocidade já corrigida
    moving = False
    if keys[pygame.K_d]:
        hero_pos_x += hero_vel_atual * dt
        moving = True
        if hero_pos_x > 768:
            hero_pos_x = old_hero_pos_x

    if keys[pygame.K_a]:
        hero_pos_x -= hero_vel_atual * dt
        moving = True
        if hero_pos_x < 0:
            hero_pos_x = old_hero_pos_x

    if keys[pygame.K_w]:
        hero_pos_y -= hero_vel_atual * dt
        moving = True
        if hero_pos_y < 0:
            hero_pos_y = old_hero_pos_y

    if keys[pygame.K_s]:
        hero_pos_y += hero_vel_atual * dt
        moving = True
        if hero_pos_y > 568:
            hero_pos_y = old_hero_pos_y
    
    # 4. Animações
    if qtdTeclasApertadas > 0:
        hero_walking_time += dt
        if hero_walking_time > 100:
            hero_walking_frame = (hero_walking_frame + 1) % 4
            hero_walking_time = 0
    else:
        hero_idle_time += dt
        if hero_idle_time > 200:
            hero_idle_frame = (hero_idle_frame + 1) % 2
            hero_idle_time = 0

def cronometrador (dt):
    global cronometro, time
    time += dt/1000
    if time < 10:
        cronometro = f'00:0{int(time)}'
    elif time < 60:
        cronometro = f'00:{int(time/10)}{int(time%10)}'
    elif time < 600:
        cronometro = f'0{int(time//60)}:{int(time%60//10)}{int(time%60%10)}'
    elif time < 6000:
        cronometro = f'{int(time//60)}:{int(time%60//10)}{int(time%60%10)}'

def update(dt):
    global hero_pos_x, hero_pos_y, hero_vel, collider_jogador, spawn_timer,moving,shoot_time, death, justUpgraded,enemyDeathCount, life, InvencibleP_actualTime, InvencibleP, paused, bounce
    # 5. Atualiza collider
    collider_jogador = pygame.Rect(hero_pos_x, hero_pos_y, 32, 32)
    spawn_timer += dt
    if spawn_timer >= enemy_spawn_interval:
        spawn_enemy()
        spawn_timer = 0
    
    inimigoMaisProx = None
    distMenor = float('inf')
    for enemy in enemies:
        distanciaJxE_X = enemy['posX'] - hero_pos_x
        distanciaJxE_Y = enemy['posY'] - hero_pos_y
        distanciaGeral = sqrt(distanciaJxE_X**2 + distanciaJxE_Y**2)

        if distanciaGeral < distMenor:
            distMenor = distanciaGeral
            inimigoMaisProx = enemy

        if enemy['posX'] > hero_pos_x:
            enemy['posX'] -= (enemy['vel']*dt)
        elif enemy['posX'] < hero_pos_x:
            enemy['posX'] += (enemy['vel']*dt)
        else:
            enemy['posX'] = enemy['posX']
        
        if enemy['posY'] > hero_pos_y:
            enemy['posY'] -= (enemy['vel']*dt)
        elif enemy['posY'] < hero_pos_y:
            enemy['posY'] += (enemy['vel']*dt)
        else:
            enemy['posY'] = enemy['posY']

        collider_enemy = pygame.Rect(enemy['posX'], enemy['posY'], 20,20)

        if colide_circulo_retangulo(hero_pos_x+16,hero_pos_y+16,circleRadius,collider_enemy) and not enemy['invencibility']:
            enemy['life'] -= circleDamage
            enemy['invencibility'] = True
            enemy['invencibility_actualTime'] = 0
            if circleDamage != 0:
                collisions.append({
                        "dmg"   : circleDamage,
                        "x"     : enemy['posX'],
                        "y"     : enemy['posY'],
                        "timer" : 600          # milissegundos que o texto ficará visível
                    })
                
        if collider_jogador.colliderect(collider_enemy) and not InvencibleP:
            life -= 1
            InvencibleP = True
            InvencibleP_actualTime = 0
            if life == 0:
                death = True

        if enemy['invencibility']:
            enemy['invencibility_actualTime'] += dt
            if enemy['invencibility_actualTime'] >= InvencibleE_lengt:
                enemy['invencibility'] = False
                enemy['invencibility_actualTime'] = 0

        if enemy['life'] <= 0:
                enemies.remove(enemy)
                if not death:
                    enemyDeathCount += 1
                if vidaInimigo == 10 or vidaInimigo == 11:
                        ganhar_xp(1)
                else:
                    ganhar_xp((vidaInimigo-10)//2)

    for pop in collisions[:]:        # itera sobre cópia para poder remover
        pop["timer"] -= dt
        pop["y"] -= 0.03 * dt  
        if pop["timer"] <= 0:
            collisions.remove(pop)

    shoot_time += dt
    if shoot_time >= shoot_rate and inimigoMaisProx:
        dx = inimigoMaisProx["posX"] - hero_pos_x
        dy = inimigoMaisProx["posY"] - hero_pos_y
        shoot(dx, dy)
        shoot_time = 0

    for tiro in projectiles[:]:
         alvo = tiro["alvo"]
         if alvo not in enemies:
            projectiles.remove(tiro)
            continue

         dx = alvo['posX'] - tiro['x']
         dy = alvo['posY'] - tiro['y']
         dist = sqrt(dx**2 + dy**2)

         if dist != 0:
             tiro['x'] += (tiro['vel'] * dx / dist) * dt
             tiro['y'] += (tiro['vel'] * dy / dist) * dt

         # Checa colisão
         tiro_rect = pygame.Rect(tiro["x"], tiro["y"], 5, 5)
         alvo_rect = pygame.Rect(alvo["posX"], alvo["posY"], 20, 20)
         if tiro_rect.colliderect(alvo_rect):
            if not alvo['invencibility']:
                alvo['life'] -= tiro['damage']
                collisions.append({
                    "dmg"   : tiro['damage'],
                    "x"     : tiro['x'],
                    "y"     : tiro['y'],
                    "timer" : 600          # milissegundos que o texto ficará visível
                })
                alvo['invencibility'] = True
                alvo['invencibility_actualTime'] = 0
                tiro['bounc_rest'] -= 1

                if tiro['bounc_rest'] > 0 and tiro['damage'] > 0:
                    tiro['damage'] -= 4
                    # candidatos = todos os inimigos EXCETO o que acabou de levar o hit
                    candidatos = [e for e in enemies if e is not alvo]
                    if candidatos:                               # existe alguém além dele?
                        novo_alvo = min(
                            candidatos,
                            key=lambda e: sqrt((e['posX'] - tiro['x'])**2 + (e['posY'] - tiro['y'])**2)
                        )
                        tiro['alvo'] = novo_alvo
                        # opcional: empurra 1 px para fora do antigo alvo
                        dx2 = novo_alvo['posX'] - tiro['x']
                        dy2 = novo_alvo['posY'] - tiro['y']
                        dist2 = max(1, sqrt(dx2**2 + dy2**2))
                        tiro['x'] += dx2 / dist2
                        tiro['y'] += dy2 / dist2
                    else:
                        # não há outro alvo — descarta o projétil
                        projectiles.remove(tiro)
                else:
                    projectiles.remove(tiro)
            else:
                # inimigo ainda está invencível, não faz nada nesse frame
                pass

    if InvencibleP:
        InvencibleP_actualTime += dt
        if InvencibleP_actualTime>= InvencibleP_lengt:
            InvencibleP = False
            justUpgraded = False
            InvencibleP_actualTime = 0
    
    for orb in orbitals:
        # avança ângulo
        orb["angle"] += orb["speed"] * dt
        # mantém ângulo na faixa 0..2π para evitar overflow
        if orb["angle"] > 6.283:
            orb["angle"] -= 6.283

        # posição relativa ao jogador
        cx = hero_pos_x + 16 + orb["radius"] * cos(orb["angle"])
        cy = hero_pos_y + 16 + orb["radius"] * sin(orb["angle"])

        orb_rect = pygame.Rect(cx - orb["size"]//2, cy - orb["size"]//2,
                            orb["size"], orb["size"])

        # colisão com inimigos (sem destruir a bala)
        for enemy in enemies[:]:
            enemy_rect = pygame.Rect(enemy['posX'], enemy['posY'], 20, 20)
            if orb_rect.colliderect(enemy_rect) and not enemy['invencibility']:
                enemy['life'] -= orb["damage"]
                collisions.append({
                    "dmg"   : shoot_damage//2,
                    "x"     : enemy['posX'],
                    "y"     : enemy['posY'],
                    "timer" : 600          # milissegundos que o texto ficará visível
                })
                enemy['invencibility'] = True
                enemy['invencibility_actualTime'] = 0
           
def draw_screen(screen):
    screen.fill((150,200,250))
    if not death:
        pygame.draw.circle(screen,("#70aaff"),(hero_pos_x+16,hero_pos_y+16),circleRadius)
        if not moving:
            screen.blit(hero_idle[hero_idle_frame], (hero_pos_x-8, hero_pos_y-8))
        else:
            screen.blit(hero_walking[hero_walking_frame],(hero_pos_x-8, hero_pos_y-8))
        for enemy in enemies:
            collider_enemy = pygame.Rect(enemy['posX'], enemy['posY'], 20,20)
            pygame.draw.rect(screen,("#ff0000"), collider_enemy)
        for tiro in projectiles:
            pygame.draw.circle(screen, "#ffffff", (tiro["x"], tiro["y"]), 5)
        fonteDamage = pygame.font.SysFont(None, 20)
        for pop in collisions:
            txt = fonteDamage.render(str(pop["dmg"]), True, "#ffffff")
            screen.blit(txt, (pop["x"], pop["y"]))
        for orb in orbitals:
            cx = hero_pos_x + 16 + orb["radius"] * cos(orb["angle"])
            cy = hero_pos_y + 16 + orb["radius"] * sin(orb["angle"])
            pygame.draw.circle(screen, "#ffffff",
                                        (cx - orb["size"]//2,
                                        cy - orb["size"]//2),
                                        5)
        if InvencibleP and InvencibleP_actualTime < 500 and not justUpgraded:
            screen.blit(damage,(0,0))
        fonteCronometro = pygame.font.SysFont(None, 30)
        cronometroTxt = fonteCronometro.render(cronometro, True, '#ffffff')
        screen.blit(cronometroTxt, (370,0))
        fonteKillCount = pygame.font.SysFont(None,20)
        killCountTxt = fonteKillCount.render(f'Inimigos Mortos: {enemyDeathCount}', True, '#ffffff')
        screen.blit(killCountTxt, (660,0))
        pygame.draw.rect(screen,("#999999"),(0,575,800,600))
        pygame.draw.rect(screen,("#0000ff"),(0,575,(xp/xp_necessario*800),600))
        fonteXP = pygame.font.SysFont(None, 20)
        xpTxt = fonteXP.render(f'Nível: {nivel}', True, '#ffffff')
        screen.blit(xpTxt, (375, 580))
        x = 0
        y = 0
        p = 0
        for i in range (life):
            if i % 2 == 0:
                screen.blit(coracao, (x,y))
            else:
                screen.blit(pygame.transform.flip(coracao, True,False),(x,y))
                x += 5
            x += 13
            p += 1
            if p % 24 == 0:
                y += 30
                x = 0

        if escolhendo_habilidade:
            font = pygame.font.SysFont(None, 32)
            for i, arma in enumerate(opcoes_sorteadas):
                txt = f"{i+1}. {arma[0]} (nível atual: {arma[1]})"
                rendered = font.render(txt, True, "#ffffff")
                screen.blit(rendered, (100, 200 + i * 40))
                if arma[0] == 'Vida':
                    screen.blit(lifeImage,(60,195 + i * 40))
                elif arma[0] == 'Bola de Neve Orbital':
                    screen.blit(orbitImage,(60,195+i*40))
            
            
    else:
        screen.blit(damage,(0,0))
        fontedeath = pygame.font.SysFont(None, 100)
        texto = fontedeath.render('VOCÊ MORREU!', True, "#271BD5")
        screen.blit(texto, (120, 250))
        fonteEnemies = pygame.font.SysFont(None, 25)
        textoEnemies2 = fonteEnemies.render(f'Inimigos eliminados: {enemyDeathCount}', True, "#ffffff")
        screen.blit(textoEnemies2,(500,375))
        fonteCron = pygame.font.SysFont(None, 25)
        textoCron = fonteCron.render(f'Tempo sobrevivido: {cronometro}',True,"#ffffff")
        screen.blit(textoCron,(270,375))
        fonteNivel = pygame.font.SysFont(None,25)
        textoNivel = fonteNivel.render(f'Nível alcançado: {nivel}', True, "#ffffff")
        screen.blit(textoNivel,(90,375))
        fonteRejogar = pygame.font.SysFont(None,40)
        textoRejogar = fonteRejogar.render('Pressione Enter para Rejogar', True, "#ffffff")
        screen.blit(textoRejogar,(200,450))

def draw_pause_overlay(screen):
    screen.blit(telaPause,(0,0))

def draw_menu(screen):
    screen.blit(menu,(0,0))
#####################################################
# A PRINCIPIO NÃO PRECISA ALTERAR DAQUI PRA BAIXO   #
#####################################################
def main_loop(screen):  
    global clock, paused, escolhendo_habilidade, bounce, spawn_timer, xp_necessario ,circleDamage,shoot_rate, circleRadius,InvencibleP, nivel, xp, enemyDeathCount ,velOrb, shoot_damage ,justUpgraded, orbital_level, noMenu, death, life, hero_pos_x, hero_pos_y, time, hero_vel
    running_right = True
    while running_right:
        # Define FPS máximo
        clock.tick(60)
        # time transcorrido desde a última atualização 
        dt = clock.get_time()

        if not noMenu:
            for e in pygame.event.get(): 
                if e.type == pygame.QUIT: # fechamento do prog
                    running_right = False
                    break
                elif e.type == pygame.KEYDOWN:
                    if e.key == pygame.K_ESCAPE:
                        paused = not paused
                    if escolhendo_habilidade:
                        paused = True
                        InvencibleP = True
                        justUpgraded = True
                        if e.key == pygame.K_1:
                            selecionaArma(opcoes_sorteadas[0])
                            escolhendo_habilidade = False
                            paused = False
                        elif e.key == pygame.K_2:
                            selecionaArma(opcoes_sorteadas[1])
                            escolhendo_habilidade = False
                            paused = False
                        elif e.key == pygame.K_3:
                            selecionaArma(opcoes_sorteadas[2])
                            escolhendo_habilidade = False
                            paused = False

                    if death == True:
                        if e.key == pygame.K_0:
                            spawn_timer = 0
                            life = 6
                            hero_pos_x = 376
                            hero_pos_y = 276
                            hero_vel = 0.2
                            orbital_level = 0
                            rebuild_orbitals()
                            velOrb = 0.001
                            time = 0
                            shoot_damage = 10
                            xp = 0
                            xp_necessario = 5
                            nivel = 1
                            circleDamage = 0
                            circleRadius = 0
                            shoot_rate = 2000
                            enemyDeathCount = 0
                            bounce = 1
                            death = False
                            InvencibleP = False

            if death == True:
                spawn_timer = 0
                for enemy in enemies:
                    enemies.remove(enemy)

            # Atualiza posição dos objetos
            if not paused and not death:
                movimentacao_player(dt)
                cronometrador(dt)
                update(dt)
            # Desenha objetos
            draw_screen(screen)
            if paused and not death and not escolhendo_habilidade:
                draw_pause_overlay(screen)
            # Pygame atualiza a visualização da tela
            pygame.display.update()
        else:
            draw_menu(screen)
            pygame.display.update()  # Atualiza o menu na tela
            for e in pygame.event.get():
                posX_mouse, posY_mouse = pygame.mouse.get_pos()
                if e.type == pygame.MOUSEBUTTONDOWN and 290 < posX_mouse < 510 and 380 < posY_mouse < 450:
                    noMenu = False 
                if e.type == pygame.QUIT: # fechamento do prog
                    running_right = False
                    break

# Programa principal
pygame.init()
screen = pygame.display.set_mode((width, height))
load()
main_loop(screen)
pygame.quit()